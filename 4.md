# for

py 可以迭代列表或字符串等任意序列

> 遍历集合时修改集合的内容，会很容易生成错误的结果。因此不能直接进行循环，而是应遍历该集合的副本或创建新的集合：

```python
items = ["alapha", "boy", "cat"]
# items = "wasd" # 取消注释看看

for i in items:
    print(i, len(i))


users = {"Hans": "active", "Éléonore": "inactive", "景太郎": "active"}

# 思路1:  先复制再用来遍历
for user, status in users.copy().items():
    if status == "inactive":
        del users[user]
print(users) # {'Hans': 'active', '景太郎': 'active'}

# 思路2:  创建新集合
active_users = {}
for user, status in users.items():
    if status == "active":
        active_users[user] = status
print(active_users) # {'Hans': 'active', '景太郎': 'active'}

# 错误思路：修改被遍历对象会引发意想不到的错误
for user, status in users:
    if status == "inactive":
        del users[user]
print(users)
```

上面最后一个 for 实测会发生错误 `Exception has occurred: ValueError too many values to unpack (expected 2)`. 之前我在写贪吃蛇的时候，遍历蛇身是否吃到食物，吃到就修改蛇的长度，这就是前面说的典型错误，发生了预料之外的结果


## break continue

教程中举的continue感觉怪怪的，完全可以用else

> ```python
> >>> for num in range(2, 10):
> ...     if num % 2 == 0:
> ...         print("Found an even number", num)
> ...         continue
> ...     print("Found an odd number", num)
> ```
>
> 

```python
for num in range(2, 10):
    if num % 2 == 0:
        print("Found an even number", num)
    else:
        print("Found an odd number", num)
```



## else


循环（for while）可以配套 else，千真万确

> 循环语句支持 `else` 子句；[`for`](https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for) 循环中，可迭代对象中的元素全部循环完毕，或 [`while`](https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#while) 循环的条件为假时，执行该子句；[`break`](https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#break) 语句终止循环时，不执行该子句。 请看下面这个查找素数的循环示例：
>
> ```python
> >>> for n in range(2, 10):
> ...     for x in range(2, n):
> ...         if n % x == 0:
> ...             print(n, 'equals', x, '*', n//x)
> ...             break
> ...     else:
> ...         # loop fell through without finding a factor
> ...         print(n, 'is a prime number')
> ...
> 2 is a prime number
> 3 is a prime number
> 4 equals 2 * 2
> 5 is a prime number
> 6 equals 2 * 3
> 7 is a prime number
> 8 equals 2 * 4
> 9 equals 3 * 3
> ```



# range

迭代次数可以很好的借助这个函数实现，这个类似切片的半闭半开区间，也可以指定 步长

```python
>>> list(range(3))
[0, 1, 2]
>>> list(range(3,6))
[3, 4, 5]
>>> list(range(2,10,2))
[2, 4, 6, 8]
>>> list(range(-2,-10,-2))
[-2, -4, -6, -8]
```



> [`range()`](https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range) 和 [`len()`](https://docs.python.org/zh-cn/3.10/library/functions.html#len) 组合在一起，可以按索引迭代序列

```python
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

不是很理解上面的操作，毕竟我遇到过，这样操作结果一样

```python
for i in a:
    print(a.index(i), i)
    
# 5.6 给出了另一种办法 https://docs.python.org/zh-cn/3.10/tutorial/datastructures.html#tut-loopidioms
for i, v in enumerate(a):
    print(i, v)
```

不过直接输出 range,结果很奇怪，教程说的是其返回的是 可迭代对象 [iterable](https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable)，丢入能接受 可迭代对象 参数的函数才能有结果，比如 sum、list

```python
>>> range(3)
range(0, 3)
>>> print(range(3))
range(0, 3)
>>> sum(range(-2,-10,-2))
-20
```

